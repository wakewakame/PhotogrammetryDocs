<!DOCTYPE html>
<html>
	<head>
		<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<title>8 point algorithm demo</title>
		<script type="module">
			import renderer from "./renderer.js";
			import vector from "./vector.js";

			const main = () => {
				const points = [
					[-1, -1, -1],
					[+1, -1, -1],
					[+1, +1, -1],
					[-1, +1, -1],
					[-1, -1, +1],
					[+1, -1, +1],
					[+1, +1, +1],
					[-1, +1, +1],
				];
				for(let i = 0; i < 0; i++) {
					const x = Math.random() * 2 - 1;
					const y = Math.random() * 2 - 1;
					const z = Math.random() * 2 - 1;
					points.push([x, y, z]);
				}
				const cam1  = document.getElementById("cam1");
				const cam2  = document.getElementById("cam2");
				const world = document.getElementById("world");
				const points_cam1  = new renderer.Points3D(cam1 , points);
				const points_cam2  = new renderer.Points3D(cam2 , points);
				const points_world = new renderer.Points3D(world, points);
				points_cam1.addOtherCamera([cam2]);
				points_cam2.addOtherCamera([cam1]);
				points_world.addOtherCamera([cam1, cam2]);

				const calc = async () => {
					// 回転行列と平行移動ベクトル、点群の三次元座標を計算
					const body = JSON.stringify({
						"cam1": vector.matToOpencvIntrinsics(points_cam1.r3d.matrix.projection),
						"cam2": vector.matToOpencvIntrinsics(points_cam2.r3d.matrix.projection),
						"points1": points_cam1.r3d.worldToScreen(points).map(point => [point.x, point.y]),
						"points2": points_cam2.r3d.worldToScreen(points).map(point => [point.x, point.y]),
					});
					const response = await fetch("/8pt", {method: "POST", body: body});
					const data = await response.json();
					if (data === null) { return; }
					const Rt_ = DOMMatrix.fromFloat64Array(new Float64Array([
						data["Rt"][0][0], data["Rt"][1][0], data["Rt"][2][0], 0,
						data["Rt"][0][1], data["Rt"][1][1], data["Rt"][2][1], 0,
						data["Rt"][0][2], data["Rt"][1][2], data["Rt"][2][2], 0,
						data["Rt"][0][3], data["Rt"][1][3], data["Rt"][2][3], 1
					]));
					let points_ = data["points"];

					// 現実の回転行列と平行移動ベクトルを計算
					const Rt = points_cam2.r3d.matrix.view.multiply(points_cam1.r3d.matrix.view.inverse());

					// Rt_とRtの平行移動成分の長さから、Rt_とpoints_のスケールをRtとpointsに合わせる
					const Rt_length_ = Math.sqrt(Rt_.m41 * Rt_.m41 + Rt_.m42 * Rt_.m42 + Rt_.m43 * Rt_.m43);
					const Rt_length = Math.sqrt(Rt.m41 * Rt.m41 + Rt.m42 * Rt.m42 + Rt.m43 * Rt.m43);
					const scale = Rt_length / Rt_length_;
					Rt_.m41 *= scale; Rt_.m42 *= scale; Rt_.m43 *= scale;
					points_ = points_.map(([x, y, z]) => [x * scale, y * scale, z * scale]);

					// points_をcam1座標系から世界座標系へ変形
					points_ = points_.map(([x, y, z]) => {
						let point = new DOMPoint(x, y, z, 1);
						point = points_cam1.r3d.matrix.view.inverse().transformPoint(point);
						return [point.x, point.y, point.z, 1];
					});

					console.log(points);
					console.log(points_);
				};
				cam1.addEventListener("mouseup", async () => { calc(); });
				cam2.addEventListener("mouseup", async () => { calc(); });
			};

			window.addEventListener("DOMContentLoaded", () => {
				main();
			});
		</script>
		<style>
			body {
				background: #E4E6E5;
			}
			canvas {
				background: #E4E6E5;
				border: 2px solid #77A9B0;
				border-radius: 16px;
				margin: 4px;
				width: 480px;
			}
		</style>
	</head>
	<body>
		<div>
			<canvas id="cam1"  width="640" height="480"></canvas>
			<canvas id="cam2"  width="640" height="480"></canvas>
			<canvas id="world" width="640" height="480"></canvas>
		</div>
	</body>
</html>
